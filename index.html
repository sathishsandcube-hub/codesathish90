<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Side-by-Side Photo Merger</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .upload-box {
            border: 3px dashed #cbd5e0;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            background: #f7fafc;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }
        
        .upload-box:hover {
            border-color: #667eea;
            background: #edf2f7;
            transform: translateY(-2px);
        }
        
        .upload-box.dragover {
            border-color: #667eea;
            background: #e6fffa;
        }
        
        .file-input {
            display: none;
        }
        
        .upload-icon {
            font-size: 3em;
            color: #a0aec0;
            margin-bottom: 15px;
        }
        
        .upload-text {
            color: #718096;
            font-size: 1.1em;
            margin-bottom: 10px;
        }
        
        .preview-container {
            margin-top: 20px;
            max-height: 300px;
            overflow: hidden;
            border-radius: 10px;
        }
        
        .preview-image {
            width: 100%;
            height: auto;
            max-height: 300px;
            object-fit: cover;
            border-radius: 10px;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #f7fafc;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        label {
            font-weight: 500;
            color: #4a5568;
            min-width: 80px;
        }
        
        select, input[type="range"], input[type="color"] {
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            background: white;
        }
        
        input[type="range"], input[type="color"] {
            width: 120px;
        }
        
        input[type="color"] {
            padding: 2px;
            width: 40px;
            height: 30px;
            border-radius: 6px;
        }
        
        .btn {
            padding: 15px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .result-section {
            margin-top: 40px;
            text-align: center;
        }
        
        .result-canvas {
            border: 1px solid #e2e8f0;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            max-width: 100%;
            height: auto;
        }
        
        .download-btn {
            margin-top: 20px;
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            box-shadow: 0 4px 15px rgba(72, 187, 120, 0.4);
        }
        
        .download-btn:hover {
            box-shadow: 0 8px 25px rgba(72, 187, 120, 0.6);
        }
        
        .position-controls {
            background: #f8f9ff;
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid #e6edff;
        }
        
        .position-controls h3 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 25px;
            font-size: 1.4em;
        }
        
        .position-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 25px;
        }
        
        .position-section {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        
        .position-section h4 {
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 1.1em;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 2px solid #e2e8f0;
        }
        
        .position-control-group {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .position-control-group label {
            min-width: 70px;
            font-weight: 500;
            color: #4a5568;
        }
        
        .position-control-group input[type="range"] {
            flex: 1;
            min-width: 120px;
        }
        
        .position-control-group span {
            min-width: 40px;
            font-weight: 600;
            color: #2d3748;
            text-align: right;
        }
        
        .position-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .reset-btn {
            background: linear-gradient(135deg, #fc8181 0%, #f56565 100%);
            box-shadow: 0 4px 15px rgba(252, 129, 129, 0.4);
        }
        
        .reset-btn:hover {
            box-shadow: 0 8px 25px rgba(252, 129, 129, 0.6);
        }
        
        .text-overlay-controls, .preview-mode-controls {
            background: #f0f8ff;
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            border: 2px solid #cfe2ff;
        }
        
        .text-overlay-controls h3, .preview-mode-controls h3 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 25px;
            font-size: 1.4em;
        }
        
        .text-controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 25px;
        }
        
        .text-section {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        
        .text-section h4 {
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 1.1em;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 2px solid #e2e8f0;
        }
        
        .text-control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .text-control-group label {
            min-width: 80px;
            font-weight: 500;
            color: #4a5568;
        }
        
        .text-control-group input[type="text"] {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            min-width: 150px;
        }
        
        .text-control-group select {
            flex: 1;
            min-width: 120px;
        }
        
        .text-buttons, .preview-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .preview-btn {
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
            box-shadow: 0 4px 15px rgba(66, 153, 225, 0.4);
            min-width: 160px;
        }
        
        .preview-btn:hover {
            box-shadow: 0 8px 25px rgba(66, 153, 225, 0.6);
        }
        
        .preview-btn.active {
            background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
            box-shadow: 0 4px 15px rgba(56, 161, 105, 0.4);
        }
        
        .download-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .download-input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .download-input-group label {
            font-weight: 500;
            color: #4a5568;
        }
        
        .download-input-group input {
            padding: 10px 15px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            min-width: 200px;
        }
        
        @media (max-width: 768px) {
            .upload-section {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .control-group {
                width: 100%;
                justify-content: space-between;
            }
            
            .position-grid {
                grid-template-columns: 1fr;
            }
            
            .position-buttons {
                flex-direction: column;
                align-items: stretch;
            }
            
            .text-controls-grid {
                grid-template-columns: 1fr;
            }
            
            .preview-buttons, .text-buttons {
                flex-direction: column;
                align-items: stretch;
            }
            
            .download-controls {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>📸 Side-by-Side Photo Merger</h1>
        
        <div class="upload-section">
            <div class="upload-box" onclick="document.getElementById('leftImage').click()" 
                 ondragover="handleDragOver(event)" ondrop="handleDrop(event, 'left')">
                <input type="file" id="leftImage" class="file-input" accept="image/*" onchange="loadImage(this, 'left')">
                <div class="upload-icon">📷</div>
                <div class="upload-text">Click or drag to upload<br><strong>Left Image</strong></div>
                <div id="leftPreview" class="preview-container" style="display: none;">
                    <img id="leftImg" class="preview-image">
                </div>
            </div>
            
            <div class="upload-box" onclick="document.getElementById('rightImage').click()"
                 ondragover="handleDragOver(event)" ondrop="handleDrop(event, 'right')">
                <input type="file" id="rightImage" class="file-input" accept="image/*" onchange="loadImage(this, 'right')">
                <div class="upload-icon">📷</div>
                <div class="upload-text">Click or drag to upload<br><strong>Right Image</strong></div>
                <div id="rightPreview" class="preview-container" style="display: none;">
                    <img id="rightImg" class="preview-image">
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="outputFormat">Format:</label>
                <select id="outputFormat">
                    <option value="jpeg">JPEG</option>
                    <option value="png">PNG</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="quality">Quality:</label>
                <input type="range" id="quality" min="0.1" max="1" step="0.1" value="0.9">
                <span id="qualityValue">90%</span>
            </div>
            
            <div class="control-group">
                <label for="spacing">Gap:</label>
                <input type="range" id="spacing" min="0" max="50" value="5">
                <span id="spacingValue">15px</span>
            </div>
            
            <div class="control-group">
                <label for="borderWidth">Border:</label>
                <input type="range" id="borderWidth" min="0" max="20" value="0">
                <span id="borderValue">0px</span>
            </div>
            
            <div class="control-group">
                <label for="borderColor">Border Color:</label>
                <input type="color" id="borderColor" value="#000000">
            </div>
            
            <button class="btn" onclick="swapImages()" id="swapBtn" disabled>
                🔄 Swap Positions
            </button>
            
            <button class="btn" onclick="mergeImages()" id="mergeBtn" disabled>
                ✨ Merge Photos
            </button>
        </div>
        
        <!-- Text Overlay Controls -->
        <div class="text-overlay-controls" id="textOverlayControls" style="display: none;">
            <h3>📝 Add Text Overlay</h3>
            <div class="text-controls-grid">
                <div class="text-section">
                    <h4>Text Content</h4>
                    <div class="text-control-group">
                        <label>Caption/Title:</label>
                        <input type="text" id="overlayText" placeholder="Enter your text here..." maxlength="100">
                    </div>
                    <div class="text-control-group">
                        <label>Position:</label>
                        <select id="textPosition">
                            <option value="top-center" selected>Top Center</option>
                            <option value="top-left">Top Left</option>
                            <option value="top-right">Top Right</option>
                            <option value="center">Center</option>
                            <option value="bottom-left">Bottom Left</option>
                            <option value="bottom-center">Bottom Center</option>
                            <option value="bottom-right">Bottom Right</option>
                        </select>
                    </div>
                </div>
                
                <div class="text-section">
                    <h4>Text Style</h4>
                    <div class="text-control-group">
                        <label>Font Size:</label>
                        <input type="range" id="fontSize" min="12" max="72" value="24">
                        <span id="fontSizeValue">43px</span>
                    </div>
                    <div class="text-control-group">
                        <label>Font Color:</label>
                        <input type="color" id="fontColor" value="#000000">
                    </div>
                    <div class="text-control-group">
                        <label>Background:</label>
                        <input type="color" id="textBackground" value="#ffffff">
                        <label style="min-width: auto;"><input type="checkbox" id="textBgEnabled" checked> Enable</label>
                    </div>
                </div>
            </div>
            
            <div class="text-buttons">
                <button class="btn" onclick="addTextOverlay()">
                    ➕ Add Text
                </button>
                <button class="btn reset-btn" onclick="clearText()">
                    🗑️ Clear Text
                </button>
            </div>
        </div>
        
        <!-- Preview Mode Controls -->
        <div class="preview-mode-controls" id="previewModeControls" style="display: none;">
            <h3>👁️ Preview Modes</h3>
            <div class="preview-buttons">
                <button class="btn preview-btn" onclick="showPreviewMode('original')" id="originalBtn">
                    🖼️ Original Images
                </button>
                <button class="btn preview-btn active" onclick="showPreviewMode('merged')" id="mergedBtn">
                    🎯 Merged Result
                </button>
                <button class="btn preview-btn" onclick="showPreviewMode('split')" id="splitBtn">
                    ⚡ Before/After Split
                </button>
            </div>
        </div>
        
        <!-- Position Adjustment Controls -->
        <div class="position-controls" id="positionControls" style="display: none;">
            <h3>🎯 Fine-tune Image Positions</h3>
            <div class="position-grid">
                <div class="position-section">
                    <h4>Left Image Position</h4>
                    <div class="position-control-group">
                        <label>Horizontal:</label>
                        <input type="range" id="leftX" min="-100" max="100" value="0">
                        <span id="leftXValue">0px</span>
                    </div>
                    <div class="position-control-group">
                        <label>Vertical:</label>
                        <input type="range" id="leftY" min="-100" max="100" value="0">
                        <span id="leftYValue">0px</span>
                    </div>
                </div>
                
                <div class="position-section">
                    <h4>Right Image Position</h4>
                    <div class="position-control-group">
                        <label>Horizontal:</label>
                        <input type="range" id="rightX" min="-100" max="100" value="0">
                        <span id="rightXValue">0px</span>
                    </div>
                    <div class="position-control-group">
                        <label>Vertical:</label>
                        <input type="range" id="rightY" min="-100" max="100" value="0">
                        <span id="rightYValue">0px</span>
                    </div>
                </div>
            </div>
            
            <div class="position-buttons">
                <button class="btn reset-btn" onclick="resetPositions()">
                    ↺ Reset Positions
                </button>
                <button class="btn" onclick="mergeImages()">
                    🔄 Update Preview
                </button>
            </div>
        </div>
        
        <div class="result-section" id="resultSection" style="display: none;">
            <canvas id="resultCanvas" class="result-canvas"></canvas>
            <br>
            
            <!-- Download Controls -->
            <div class="download-controls">
                <div class="download-input-group">
                    <label for="fileName">File Name:</label>
                    <input type="text" id="fileName" placeholder="merged-photos" value="merged-photos">
                </div>
                <button class="btn download-btn" onclick="downloadImage()">
                    💾 Download Merged Image
                </button>
            </div>
        </div>
    </div>

    <script>
        let leftImageData = null;
        let rightImageData = null;
        
        // Update quality display
        document.getElementById('quality').addEventListener('input', function() {
            document.getElementById('qualityValue').textContent = Math.round(this.value * 100) + '%';
        });
        
        // Update spacing display
        document.getElementById('spacing').addEventListener('input', function() {
            document.getElementById('spacingValue').textContent = this.value + 'px';
        });
        
        // Update border display
        document.getElementById('borderWidth').addEventListener('input', function() {
            document.getElementById('borderValue').textContent = this.value + 'px';
        });
        
        // Update position displays and auto-refresh
        ['leftX', 'leftY', 'rightX', 'rightY'].forEach(id => {
            document.getElementById(id).addEventListener('input', function() {
                document.getElementById(id + 'Value').textContent = this.value + 'px';
                
                // Auto-update preview if result is already shown
                if (document.getElementById('resultSection').style.display === 'block') {
                    mergeImages();
                }
            });
        });
        
        // Update font size display
        document.getElementById('fontSize').addEventListener('input', function() {
            document.getElementById('fontSizeValue').textContent = this.value + 'px';
        });
        
        let currentPreviewMode = 'merged';
        
        function handleDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        }
        
        function handleDrop(event, side) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');
            
            const files = event.dataTransfer.files;
            if (files.length > 0 && files[0].type.startsWith('image/')) {
                const input = document.getElementById(side + 'Image');
                input.files = files;
                loadImage(input, side);
            }
        }
        
        // Remove dragover class when drag leaves
        document.querySelectorAll('.upload-box').forEach(box => {
            box.addEventListener('dragleave', function() {
                this.classList.remove('dragover');
            });
        });
        
        function loadImage(input, side) {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        if (side === 'left') {
                            leftImageData = img;
                            document.getElementById('leftImg').src = e.target.result;
                            document.getElementById('leftPreview').style.display = 'block';
                        } else {
                            rightImageData = img;
                            document.getElementById('rightImg').src = e.target.result;
                            document.getElementById('rightPreview').style.display = 'block';
                        }
                        
                        // Enable merge button if both images are loaded
                        if (leftImageData && rightImageData) {
                            document.getElementById('mergeBtn').disabled = false;
                            document.getElementById('swapBtn').disabled = false;
                        }
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }
        
        function swapImages() {
            if (!leftImageData || !rightImageData) {
                alert('Please upload both images first!');
                return;
            }
            
            // Swap the image data
            const tempImage = leftImageData;
            leftImageData = rightImageData;
            rightImageData = tempImage;
            
            // Update the preview displays
            const leftSrc = document.getElementById('leftImg').src;
            const rightSrc = document.getElementById('rightImg').src;
            
            document.getElementById('leftImg').src = rightSrc;
            document.getElementById('rightImg').src = leftSrc;
            
            // Auto-merge if result is already shown
            if (document.getElementById('resultSection').style.display === 'block') {
                mergeImages();
            }
        }
        
        function resetPositions() {
            ['leftX', 'leftY', 'rightX', 'rightY'].forEach(id => {
                document.getElementById(id).value = 0;
                document.getElementById(id + 'Value').textContent = '0px';
            });
            
            // Auto-update preview if result is shown
            if (document.getElementById('resultSection').style.display === 'block') {
                mergeImages();
            }
        }
        
        function addTextOverlay() {
            if (document.getElementById('resultSection').style.display === 'block') {
                mergeImages();
            }
        }
        
        function clearText() {
            document.getElementById('overlayText').value = '';
            if (document.getElementById('resultSection').style.display === 'block') {
                mergeImages();
            }
        }
        
        function showPreviewMode(mode) {
            currentPreviewMode = mode;
            
            // Update active button
            document.querySelectorAll('.preview-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode + 'Btn').classList.add('active');
            
            const canvas = document.getElementById('resultCanvas');
            const ctx = canvas.getContext('2d');
            
            if (mode === 'original') {
                showOriginalImages();
            } else if (mode === 'split') {
                showSplitView();
            } else {
                mergeImages(); // Show merged result
            }
        }
        
        function showOriginalImages() {
            const canvas = document.getElementById('resultCanvas');
            const ctx = canvas.getContext('2d');
            
            const totalWidth = leftImageData.width + rightImageData.width + 40; // 20px gap
            const maxHeight = Math.max(leftImageData.height, rightImageData.height) + 60; // padding
            
            canvas.width = totalWidth;
            canvas.height = maxHeight;
            
            // White background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add "ORIGINAL" label
            ctx.fillStyle = '#666666';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ORIGINAL IMAGES', canvas.width / 2, 25);
            
            // Draw original images
            const leftY = (maxHeight - leftImageData.height) / 2;
            const rightY = (maxHeight - rightImageData.height) / 2;
            
            ctx.drawImage(leftImageData, 10, leftY);
            ctx.drawImage(rightImageData, leftImageData.width + 30, rightY);
        }
        
        function showSplitView() {
            const canvas = document.getElementById('resultCanvas');
            const ctx = canvas.getContext('2d');
            
            // Create merged image first (in memory)
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // Get current settings for merged view
            const spacing = parseInt(document.getElementById('spacing').value);
            const borderWidth = parseInt(document.getElementById('borderWidth').value);
            const leftXOffset = parseInt(document.getElementById('leftX').value);
            const leftYOffset = parseInt(document.getElementById('leftY').value);
            const rightXOffset = parseInt(document.getElementById('rightX').value);
            const rightYOffset = parseInt(document.getElementById('rightY').value);
            
            // Calculate merged dimensions
            const mergedHeight = Math.max(
                leftImageData.height + Math.abs(leftYOffset), 
                rightImageData.height + Math.abs(rightYOffset)
            ) + (borderWidth * 2) + 100;
            
            const mergedWidth = leftImageData.width + rightImageData.width + spacing + (borderWidth * 4) + 
                              Math.abs(leftXOffset) + Math.abs(rightXOffset) + 100;
            
            tempCanvas.width = mergedWidth;
            tempCanvas.height = mergedHeight;
            
            // Draw merged version to temp canvas (simplified version)
            tempCtx.fillStyle = '#ffffff';
            tempCtx.fillRect(0, 0, mergedWidth, mergedHeight);
            
            const baseLeftX = borderWidth + 50 + Math.max(0, -leftXOffset);
            const baseLeftY = (mergedHeight - leftImageData.height) / 2 + Math.max(0, -leftYOffset);
            const baseRightX = baseLeftX + leftImageData.width + spacing + (borderWidth * 2) + Math.max(0, -rightXOffset);
            const baseRightY = (mergedHeight - rightImageData.height) / 2 + Math.max(0, -rightYOffset);
            
            const leftX = baseLeftX + leftXOffset;
            const leftY = baseLeftY + leftYOffset;
            const rightX = baseRightX + rightXOffset;
            const rightY = baseRightY + rightYOffset;
            
            tempCtx.drawImage(leftImageData, leftX, leftY);
            tempCtx.drawImage(rightImageData, rightX, rightY);
            
            // Now create split view
            const maxWidth = Math.max(mergedWidth, leftImageData.width + rightImageData.width + 40);
            const totalHeight = mergedHeight + Math.max(leftImageData.height, rightImageData.height) + 100;
            
            canvas.width = maxWidth;
            canvas.height = totalHeight;
            
            // White background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add labels
            ctx.fillStyle = '#666666';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BEFORE (Original)', canvas.width / 2, 25);
            
            // Draw original images (top)
            const origLeftX = (canvas.width - leftImageData.width - rightImageData.width - 20) / 2;
            const origY = 40;
            ctx.drawImage(leftImageData, origLeftX, origY);
            ctx.drawImage(rightImageData, origLeftX + leftImageData.width + 20, origY);
            
            // Draw separator line
            const separatorY = origY + Math.max(leftImageData.height, rightImageData.height) + 20;
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, separatorY);
            ctx.lineTo(canvas.width, separatorY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Add "AFTER" label
            ctx.fillText('AFTER (Merged)', canvas.width / 2, separatorY + 25);
            
            // Draw merged result (bottom)
            const mergedStartY = separatorY + 40;
            const mergedX = (canvas.width - mergedWidth) / 2;
            ctx.drawImage(tempCanvas, mergedX, mergedStartY);
        }
        
        function mergeImages() {
            if (!leftImageData || !rightImageData) {
                alert('Please upload both images first!');
                return;
            }
            
            const canvas = document.getElementById('resultCanvas');
            const ctx = canvas.getContext('2d');
            const spacing = parseInt(document.getElementById('spacing').value);
            const borderWidth = parseInt(document.getElementById('borderWidth').value);
            const borderColor = document.getElementById('borderColor').value;
            
            // Get position adjustments
            const leftXOffset = parseInt(document.getElementById('leftX').value);
            const leftYOffset = parseInt(document.getElementById('leftY').value);
            const rightXOffset = parseInt(document.getElementById('rightX').value);
            const rightYOffset = parseInt(document.getElementById('rightY').value);
            
            // Get text overlay settings
            const overlayText = document.getElementById('overlayText').value;
            const textPosition = document.getElementById('textPosition').value;
            const fontSize = parseInt(document.getElementById('fontSize').value);
            const fontColor = document.getElementById('fontColor').value;
            const textBgColor = document.getElementById('textBackground').value;
            const textBgEnabled = document.getElementById('textBgEnabled').checked;
            
            // Calculate dimensions with borders and position adjustments
            let extraHeight = overlayText ? fontSize + 40 : 0; // Extra space for text
            const maxHeight = Math.max(
                leftImageData.height + Math.abs(leftYOffset), 
                rightImageData.height + Math.abs(rightYOffset)
            ) + (borderWidth * 2) + 100 + extraHeight;
            
            const totalWidth = leftImageData.width + rightImageData.width + spacing + (borderWidth * 4) + 
                              Math.abs(leftXOffset) + Math.abs(rightXOffset) + 100;
            
            // Set canvas size
            canvas.width = totalWidth;
            canvas.height = maxHeight;
            
            // Clear canvas with white background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Calculate base positions
            const textOffset = overlayText && (textPosition.includes('top')) ? fontSize + 20 : 0;
            const baseLeftX = borderWidth + 50 + Math.max(0, -leftXOffset);
            const baseLeftY = (maxHeight - leftImageData.height - extraHeight) / 2 + Math.max(0, -leftYOffset) + textOffset;
            const baseRightX = baseLeftX + leftImageData.width + spacing + (borderWidth * 2) + Math.max(0, -rightXOffset);
            const baseRightY = (maxHeight - rightImageData.height - extraHeight) / 2 + Math.max(0, -rightYOffset) + textOffset;
            
            // Apply position adjustments
            const leftX = baseLeftX + leftXOffset;
            const leftY = baseLeftY + leftYOffset;
            const rightX = baseRightX + rightXOffset;
            const rightY = baseRightY + rightYOffset;
            
            // Draw borders if enabled
            if (borderWidth > 0) {
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = borderWidth;
                
                // Left image border
                ctx.strokeRect(
                    leftX - borderWidth / 2, 
                    leftY - borderWidth / 2, 
                    leftImageData.width + borderWidth, 
                    leftImageData.height + borderWidth
                );
                
                // Right image border
                ctx.strokeRect(
                    rightX - borderWidth / 2, 
                    rightY - borderWidth / 2, 
                    rightImageData.width + borderWidth, 
                    rightImageData.height + borderWidth
                );
            }
            
            // Draw images at adjusted positions
            ctx.drawImage(leftImageData, leftX, leftY, leftImageData.width, leftImageData.height);
            ctx.drawImage(rightImageData, rightX, rightY, rightImageData.width, rightImageData.height);
            
            // Add text overlay if specified
            if (overlayText) {
                ctx.font = `${fontSize}px Arial, sans-serif`;
                ctx.textAlign = 'center';
                
                // Calculate text position
                let textX = canvas.width / 2;
                let textY;
                
                switch (textPosition) {
                    case 'top-center':
                        textY = fontSize + 10;
                        break;
                    case 'top-left':
                        ctx.textAlign = 'left';
                        textX = 20;
                        textY = fontSize + 10;
                        break;
                    case 'top-right':
                        ctx.textAlign = 'right';
                        textX = canvas.width - 20;
                        textY = fontSize + 10;
                        break;
                    case 'center':
                        textY = canvas.height / 2 + fontSize / 2;
                        break;
                    case 'bottom-left':
                        ctx.textAlign = 'left';
                        textX = 20;
                        textY = canvas.height - 10;
                        break;
                    case 'bottom-center':
                        textY = canvas.height - 10;
                        break;
                    case 'bottom-right':
                        ctx.textAlign = 'right';
                        textX = canvas.width - 20;
                        textY = canvas.height - 10;
                        break;
                }
                
                // Draw text background if enabled
                if (textBgEnabled) {
                    const textMetrics = ctx.measureText(overlayText);
                    const textWidth = textMetrics.width;
                    const padding = 10;
                    
                    let bgX = textX - textWidth / 2 - padding;
                    if (ctx.textAlign === 'left') bgX = textX - padding;
                    if (ctx.textAlign === 'right') bgX = textX - textWidth - padding;
                    
                    ctx.fillStyle = textBgColor;
                    ctx.fillRect(bgX, textY - fontSize - padding/2, textWidth + padding*2, fontSize + padding);
                }
                
                // Draw text
                ctx.fillStyle = fontColor;
                ctx.fillText(overlayText, textX, textY);
            }
            
            // Show result and additional controls
            document.getElementById('resultSection').style.display = 'block';
            document.getElementById('positionControls').style.display = 'block';
            document.getElementById('textOverlayControls').style.display = 'block';
            document.getElementById('previewModeControls').style.display = 'block';
            canvas.scrollIntoView({ behavior: 'smooth' });
        }
        
        function downloadImage() {
            const canvas = document.getElementById('resultCanvas');
            const format = document.getElementById('outputFormat').value;
            const quality = parseFloat(document.getElementById('quality').value);
            const fileName = document.getElementById('fileName').value || 'merged-photos';
            
            // Clean filename - remove invalid characters
            const cleanFileName = fileName.replace(/[^a-z0-9\-_]/gi, '_');
            
            const link = document.createElement('a');
            link.download = `${cleanFileName}.${format}`;
            
            if (format === 'jpeg') {
                link.href = canvas.toDataURL('image/jpeg', quality);
            } else {
                link.href = canvas.toDataURL('image/png');
            }
            
            link.click();
        }
    </script>
</body>
</html>